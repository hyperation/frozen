.TH "buffer.h" 3 "Tue Nov 8 2011" "Version 1.0" "frozen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
buffer.h \- 
.PP
Buffers header.  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBchunk_t\fP"
.br
.RI "\fI\fBchunk_t\fP structure \fP"
.ti -1c
.RI "struct \fBbuffer_t\fP"
.br
.RI "\fI\fBbuffer_t\fP structure \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBbuffer_process\fP(_buffer, _size, _create, _func)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBbuffer_t\fP \fBbuffer_t\fP"
.br
.ti -1c
.RI "typedef ssize_t(* \fBfunc_buffer\fP )(\fBbuffer_t\fP *buffer, off_t offset, void *buf, size_t buf_size)"
.br
.ti -1c
.RI "typedef enum \fBbuff_type\fP \fBbuff_type\fP"
.br
.RI "\fIBuffer types. \fP"
.ti -1c
.RI "typedef enum \fBchunk_type\fP \fBchunk_type\fP"
.br
.RI "\fIChunk types. \fP"
.ti -1c
.RI "typedef struct \fBchunk_t\fP \fBchunk_t\fP"
.br
.RI "\fI\fBchunk_t\fP structure \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBbuff_type\fP { \fBBUFF_TYPE_CHUNKED\fP, \fBBUFF_TYPE_IO_DIRECT\fP, \fBBUFF_TYPE_IO_CACHED\fP }"
.br
.RI "\fIBuffer types. \fP"
.ti -1c
.RI "enum \fBchunk_type\fP { \fBCHUNK_TYPE_ALLOCATED\fP, \fBCHUNK_TYPE_BARE\fP }"
.br
.RI "\fIChunk types. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBchunk_alloc\fP (size_t size)"
.br
.ti -1c
.RI "_inline size_t \fBchunk_get_size\fP (void *chunk)"
.br
.ti -1c
.RI "_inline void * \fBchunk_get_ptr\fP (void *chunk)"
.br
.ti -1c
.RI "_inline void * \fBchunk_next\fP (void *chunk)"
.br
.ti -1c
.RI "_inline void \fBchunk_free\fP (void *chunk)"
.br
.ti -1c
.RI "API void \fBbuffer_init\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIInitialize buffer. \fP"
.ti -1c
.RI "API \fBbuffer_t\fP * \fBbuffer_alloc\fP (void)"
.br
.RI "\fIAllocate new buffer. \fP"
.ti -1c
.RI "API void \fBbuffer_io_init\fP (\fBbuffer_t\fP *buffer, void *context, func_buffer read, func_buffer write, int cached)"
.br
.RI "\fIAssociate buffer with read and write functions. \fP"
.ti -1c
.RI "API \fBbuffer_t\fP * \fBbuffer_io_alloc\fP (void *context, func_buffer read, func_buffer write, int cached)"
.br
.RI "\fIAssociate buffer with read and write functions. \fP"
.ti -1c
.RI "API void \fBbuffer_init_from_bare\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.RI "\fIAssociate raw memory with buffer. \fP"
.ti -1c
.RI "API \fBbuffer_t\fP * \fBbuffer_alloc_from_bare\fP (void *ptr, size_t size)"
.br
.RI "\fIAllocate new buffer associated with raw memory. \fP"
.ti -1c
.RI "API void \fBbuffer_init_from_copy\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.RI "\fICopy raw memory to new buffer. \fP"
.ti -1c
.RI "API \fBbuffer_t\fP * \fBbuffer_alloc_from_copy\fP (void *ptr, size_t size)"
.br
.RI "\fICopy raw memory to allocated buffer. \fP"
.ti -1c
.RI "API void \fBbuffer_destroy\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIDestroy buffer. \fP"
.ti -1c
.RI "API void \fBbuffer_free\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIFree allocated buffer. \fP"
.ti -1c
.RI "API void * \fBbuffer_defragment\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIDefragment buffer to one chunk and return pointer to this chunk. \fP"
.ti -1c
.RI "API void \fBbuffer_cleanup\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIEmpty buffer. \fP"
.ti -1c
.RI "API _inline size_t \fBbuffer_get_size\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIGet buffer length. \fP"
.ti -1c
.RI "API int \fBbuffer_seek\fP (\fBbuffer_t\fP *buffer, off_t b_offset, void **p_chunk, void **p_ptr, size_t *p_rest_size)"
.br
.RI "\fISeek chunk in buffer. \fP"
.ti -1c
.RI "API ssize_t \fBbuffer_write\fP (\fBbuffer_t\fP *buffer, off_t offset, void *buf, size_t buf_size)"
.br
.RI "\fIWrite to buffer. \fP"
.ti -1c
.RI "API ssize_t \fBbuffer_read\fP (\fBbuffer_t\fP *buffer, off_t offset, void *buf, size_t buf_size)"
.br
.RI "\fIRead from buffer. \fP"
.ti -1c
.RI "API void * \fBbuffer_add_head_chunk\fP (\fBbuffer_t\fP *buffer, size_t size)"
.br
.ti -1c
.RI "API void * \fBbuffer_add_tail_chunk\fP (\fBbuffer_t\fP *buffer, size_t size)"
.br
.ti -1c
.RI "API void \fBbuffer_add_head_raw\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.ti -1c
.RI "API void \fBbuffer_add_tail_raw\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.ti -1c
.RI "API ssize_t \fBbuffer_memcpy\fP (\fBbuffer_t\fP *buffer1, off_t buffer1_off, \fBbuffer_t\fP *buffer2, off_t buffer2_off, size_t size)"
.br
.RI "\fICopy from one buffer to another. \fP"
.ti -1c
.RI "API ssize_t \fBbuffer_memcmp\fP (\fBbuffer_t\fP *buffer1, off_t buffer1_off, \fBbuffer_t\fP *buffer2, off_t buffer2_off, size_t size)"
.br
.RI "\fICompare two buffers. \fP"
.ti -1c
.RI "API ssize_t \fBbuffer_strcmp\fP (\fBbuffer_t\fP *buffer1, \fBbuffer_t\fP *buffer_2)"
.br
.ti -1c
.RI "API size_t \fBbuffer_strlen\fP (\fBbuffer_t\fP *buffer)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Buffers header. 


.SH "Function Documentation"
.PP 
.SS "API \fBbuffer_t\fP* buffer_alloc (void)"
.PP
Allocate new buffer. \fBReturns:\fP
.RS 4
\fBbuffer_t\fP * or NULL 
.RE
.PP

.SS "API \fBbuffer_t\fP* buffer_alloc_from_bare (void *ptr, size_tsize)"
.PP
Allocate new buffer associated with raw memory. \fBParameters:\fP
.RS 4
\fIptr\fP Pointer to raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "API \fBbuffer_t\fP* buffer_alloc_from_copy (void *ptr, size_tsize)"
.PP
Copy raw memory to allocated buffer. \fBParameters:\fP
.RS 4
\fIptr\fP Raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "API void buffer_cleanup (\fBbuffer_t\fP *buffer)"
.PP
Empty buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to empty 
.RE
.PP

.SS "API void* buffer_defragment (\fBbuffer_t\fP *buffer)"
.PP
Defragment buffer to one chunk and return pointer to this chunk. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to defragment 
.RE
.PP
\fBReturns:\fP
.RS 4
ptr to defragmented memory 
.PP
NULL if buffer was empty 
.RE
.PP

.SS "API void buffer_destroy (\fBbuffer_t\fP *buffer)"
.PP
Destroy buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to destroy 
.RE
.PP

.SS "API void buffer_free (\fBbuffer_t\fP *buffer)"
.PP
Free allocated buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to free 
.RE
.PP

.SS "API _inline size_t buffer_get_size (\fBbuffer_t\fP *buffer)\fC [inline]\fP"
.PP
Get buffer length. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer 
.RE
.PP

.SS "API void buffer_init (\fBbuffer_t\fP *buffer)"
.PP
Initialize buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place for buffer 
.RE
.PP

.SS "API void buffer_init_from_bare (\fBbuffer_t\fP *buffer, void *ptr, size_tsize)"
.PP
Associate raw memory with buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place to write buffer structure 
.br
\fIptr\fP Pointer to raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "API void buffer_init_from_copy (\fBbuffer_t\fP *buffer, void *ptr, size_tsize)"
.PP
Copy raw memory to new buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place to write buffer structure 
.br
\fIptr\fP Raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "API \fBbuffer_t\fP* buffer_io_alloc (void *context, func_bufferread, func_bufferwrite, intcached)"
.PP
Associate buffer with read and write functions. \fBParameters:\fP
.RS 4
\fIcontext\fP IO context for functions 
.br
\fIread\fP IO read function 
.br
\fIwrite\fP IO write function 
.br
\fIcached\fP Cache returned io buffers 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBbuffer_t\fP * 
.PP
NULL 
.RE
.PP

.SS "API void buffer_io_init (\fBbuffer_t\fP *buffer, void *context, func_bufferread, func_bufferwrite, intcached)"
.PP
Associate buffer with read and write functions. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place to write buffer structure 
.br
\fIcontext\fP IO context for functions 
.br
\fIread\fP IO read function 
.br
\fIwrite\fP IO write function 
.br
\fIcached\fP Cache returned io buffers 
.RE
.PP

.SS "API ssize_t buffer_memcmp (\fBbuffer_t\fP *buffer1, off_tbuffer1_off, \fBbuffer_t\fP *buffer2, off_tbuffer2_off, size_tsize)"
.PP
Compare two buffers. \fBParameters:\fP
.RS 4
\fIbuffer1\fP First buffer 
.br
\fIbuffer1_off\fP First buffer offset 
.br
\fIbuffer2\fP Second buffer 
.br
\fIbuffer2_off\fP Second buffer offset 
.br
\fIsize\fP Size to compare 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if buffers equal 
.PP
1 or -1 if buffers differs 
.RE
.PP

.SS "API ssize_t buffer_memcpy (\fBbuffer_t\fP *buffer1, off_tbuffer1_off, \fBbuffer_t\fP *buffer2, off_tbuffer2_off, size_tsize)"
.PP
Copy from one buffer to another. \fBParameters:\fP
.RS 4
\fIbuffer1\fP First buffer 
.br
\fIbuffer1_off\fP First buffer offset 
.br
\fIbuffer2\fP Second buffer 
.br
\fIbuffer2_off\fP Second buffer offset 
.br
\fIsize\fP Size to copy 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.PP
-EINVAL on error 
.RE
.PP

.SS "API ssize_t buffer_read (\fBbuffer_t\fP *buffer, off_tread_offset, void *buf, size_tbuf_size)"
.PP
Read from buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer 
.br
\fIread_offset\fP Offset to start writing 
.br
\fIbuf\fP Read to ptr 
.br
\fIbuf_size\fP Read length 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bytes read 
.PP
IO function error 
.PP
-1 
.RE
.PP

.SS "API int buffer_seek (\fBbuffer_t\fP *buffer, off_tb_offset, void **p_chunk, void **p_ptr, size_t *p_rest_size)"
.PP
Seek chunk in buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to seek 
.br
\fIb_offset\fP Offset 
.br
\fIp_chunk\fP Found chunk pointer 
.br
\fIp_ptr\fP Memory ptr 
.br
\fIp_rest_size\fP Memory size 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.PP
-EINVAL on error 
.RE
.PP

.SS "API ssize_t buffer_write (\fBbuffer_t\fP *buffer, off_twrite_offset, void *buf, size_tbuf_size)"
.PP
Write to buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer 
.br
\fIwrite_offset\fP Offset to start writing 
.br
\fIbuf\fP Ptr to memory 
.br
\fIbuf_size\fP Write length 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bytes written 
.PP
IO function error 
.PP
-1 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for frozen from the source code.
