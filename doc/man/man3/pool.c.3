.TH "pool.c" 3 "Thu Oct 27 2011" "Version 1.0" "frozen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pool.c \- 
.PP
Pool backend.  

.SH SYNOPSIS
.br
.PP
\fC#include <libfrozen.h>\fP
.br
\fC#include <backend.h>\fP
.br
\fC#include <pthread.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBrule\fP"
.br
.ti -1c
.RI "struct \fBpool_userdata\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBEMODULE\fP   15"
.br
.ti -1c
.RI "#define \fBPOOL_INTERVAL_DEFAULT\fP   5"
.br
.ti -1c
.RI "#define \fBTICK_INTERVAL_DEFAULT\fP   5"
.br
.ti -1c
.RI "#define \fBpool_kill_check\fP(_backend, _field, _moreless)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum parameter_method \fBparameter_method\fP"
.br
.ti -1c
.RI "typedef enum choose_method \fBchoose_method\fP"
.br
.ti -1c
.RI "typedef enum action_method \fBaction_method\fP"
.br
.ti -1c
.RI "typedef struct \fBrule\fP \fBrule\fP"
.br
.ti -1c
.RI "typedef struct \fBpool_userdata\fP \fBpool_userdata\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBparameter_method\fP { \fBPARAMETER_REQUEST\fP, \fBPARAMETER_ONE\fP, \fBPARAMETER_TICKS\fP, \fBPARAMETER_DEFAULT\fP =  PARAMETER_TICKS }"
.br
.ti -1c
.RI "enum \fBchoose_method\fP { \fBMETHOD_RANDOM\fP, \fBMETHOD_FIRST\fP, \fBMETHOD_LAST\fP, \fBMETHOD_HIGHEST\fP, \fBMETHOD_LOWEST\fP, \fBMETHOD_DEFAULT\fP =  METHOD_FIRST }"
.br
.ti -1c
.RI "enum \fBaction_method\fP { \fBACTION_DESTROY\fP, \fBACTION_REQUEST\fP, \fBACTION_DEFAULT\fP =  ACTION_REQUEST }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "uintmax_t \fBpool_parameter_get\fP (\fBbackend_t\fP *backend, \fBpool_userdata\fP *userdata)"
.br
.ti -1c
.RI "void \fBpool_backend_action\fP (\fBbackend_t\fP *backend, \fBrule\fP *\fBrule\fP)"
.br
.ti -1c
.RI "void \fBpool_group_limit\fP (\fBlist\fP *backends, \fBrule\fP *\fBrule\fP, uintmax_t need_lock)"
.br
.ti -1c
.RI "void * \fBpool_main_thread\fP (void *null)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBbackend_t\fP \fBpool_proto\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Pool backend. 

Pool module inserted in forkable backend chain can track any property of backend (like memory usage) and limit it. Underlying modules can be destroyed or call special function. 
.SH "Define Documentation"
.PP 
.SS "#define pool_kill_check(_backend, _field, _moreless)"\fBValue:\fP
.PP
.nf
{ \
                                        if(_backend == NULL){ \
                                                _backend = backend; \
                                        }else{ \
                                                if(backend_ud->_field _moreless ((pool_userdata *)_backend->userdata)->_field) \
                                                        _backend = backend; \
                                        } \
                                }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBbackend_t\fP pool_proto"\fBInitial value:\fP
.PP
.nf
 {
        .class          = 'backend/pool',
        .supported_api  = API_CRWD,
        .func_init      = &pool_init,
        .func_configure = &pool_configure,
        .func_fork      = &pool_fork,
        .func_destroy   = &pool_destroy
}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for frozen from the source code.
