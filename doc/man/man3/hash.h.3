.TH "hash.h" 3 "Tue Nov 8 2011" "Version 1.0" "frozen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
hash.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <hashkeys.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBhash_t\fP"
.br
.RI "\fIHash item. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBhash_ptr_null\fP   (hash_key_t)-1"
.br
.ti -1c
.RI "#define \fBhash_ptr_end\fP   (hash_key_t)-2"
.br
.ti -1c
.RI "#define \fBhash_ptr_inline\fP   (hash_key_t)-3"
.br
.ti -1c
.RI "#define \fBhash_null\fP   {hash_ptr_null,    {0, NULL}}"
.br
.RI "\fIMark null item here. \fP"
.ti -1c
.RI "#define \fBhash_inline\fP(hash)   {hash_ptr_inline,  DATA_PTR_HASHT(hash)}"
.br
.RI "\fIMark inline hash here. \fP"
.ti -1c
.RI "#define \fBhash_next\fP(hash)   {hash_ptr_end,     {0, (void *)hash}}"
.br
.RI "\fIMark next hash // TODO deprecate. \fP"
.ti -1c
.RI "#define \fBhash_end\fP   hash_next(NULL)"
.br
.RI "\fIMark hash end. \fP"
.ti -1c
.RI "#define \fBHK\fP(value)   HASH_KEY_##value"
.br
.RI "\fIShortcut for registed hash keys. Also used in key registration process. \fP"
.ti -1c
.RI "#define \fBhash_data_copy\fP(_ret, _type, _dt, _hash, _key)"
.br
.ti -1c
.RI "#define \fBhash_assign_hash_t\fP(_dst, _src)"
.br
.ti -1c
.RI "#define \fBhash_assign_hash_inline\fP(_dst, _hash)"
.br
.ti -1c
.RI "#define \fBhash_assign_hash_null\fP(_dst)"
.br
.ti -1c
.RI "#define \fBhash_assign_hash_end\fP(_dst)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBhash_iter_flags\fP \fBhash_iter_flags\fP"
.br
.ti -1c
.RI "typedef ssize_t(* \fBhash_iterator\fP )(\fBhash_t\fP *hash, void *arg)"
.br
.RI "\fICallback routine for hash_iter. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBhash_iter_flags\fP { \fBHASH_ITER_NULL\fP =  1, \fBHASH_ITER_END\fP =  2, \fBHASH_ITER_INLINE\fP =  4 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "API \fBhash_t\fP * \fBhash_new\fP (size_t nelements)"
.br
.RI "\fIAllocate new hash filled with hash_null. \fP"
.ti -1c
.RI "API \fBhash_t\fP * \fBhash_copy\fP (\fBhash_t\fP *hash)"
.br
.RI "\fIMake copy of supplied hash. \fP"
.ti -1c
.RI "API void \fBhash_free\fP (\fBhash_t\fP *hash)"
.br
.RI "\fIFree allocated, or copy of hash. \fP"
.ti -1c
.RI "API \fBhash_t\fP * \fBhash_find\fP (\fBhash_t\fP *hash, hash_key_t key)"
.br
.RI "\fIFind key in hash. \fP"
.ti -1c
.RI "API \fBdata_t\fP * \fBhash_data_find\fP (\fBhash_t\fP *hash, hash_key_t key)"
.br
.RI "\fIFind key in hash and return pointer to data holder. \fP"
.ti -1c
.RI "API size_t \fBhash_nelements\fP (\fBhash_t\fP *hash)"
.br
.RI "\fICount number of elements in hash. \fP"
.ti -1c
.RI "API ssize_t \fBhash_iter\fP (\fBhash_t\fP *hash, \fBhash_iterator\fP func, void *arg, \fBhash_iter_flags\fP flags)"
.br
.RI "\fIIterate all hash keys and pass them to callback. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Define Documentation"
.PP 
.SS "#define hash_assign_hash_end(_dst)"\fBValue:\fP
.PP
.nf
{  \
        (_dst)->key = hash_ptr_end;   \
        (_dst)->data.ptr = NULL;      \
}
.fi
.SS "#define hash_assign_hash_inline(_dst, _hash)"\fBValue:\fP
.PP
.nf
{  \
        (_dst)->key = hash_ptr_inline;   \
        (_dst)->data.type = TYPE_HASHT;  \
        (_dst)->data.ptr = _hash;        \
}
.fi
.SS "#define hash_assign_hash_null(_dst)"\fBValue:\fP
.PP
.nf
{  \
        (_dst)->key = hash_ptr_null;   \
        (_dst)->data.type = TYPE_VOIDT;\
        (_dst)->data.ptr = NULL;       \
}
.fi
.SS "#define hash_assign_hash_t(_dst, _src)"\fBValue:\fP
.PP
.nf
{        \
        memcpy((_dst), (_src), sizeof(hash_t)); \
}
.fi
.SS "#define hash_data_copy(_ret, _type, _dt, _hash, _key)"\fBValue:\fP
.PP
.nf
{                  \
        data_get(_ret,                                              \
                _type,                                              \
                _dt,                                                \
                hash_data_find(_hash,_key)                          \
        );                                                          \
        (void)_ret;                                                 \
};
.fi
Get value from hash 
.PP
\fBParameters:\fP
.RS 4
\fI_ret\fP Return value (ssize_t) 
.br
\fI_type\fP Destination data type. Only constants allowed. 
.br
\fI_dt\fP Destination data. 
.br
\fI_hash\fP Hash to get value from 
.br
\fI_key\fP Key to search for 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdata_get\fP 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBhash_iter_flags\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIHASH_ITER_NULL \fP\fP
Exec callback with hash_null items also. 
.TP
\fB\fIHASH_ITER_END \fP\fP
Exec callback with hash_end items also. 
.TP
\fB\fIHASH_ITER_INLINE \fP\fP
Exec callback with hash_inline items also. 
.SH "Function Documentation"
.PP 
.SS "API ssize_t hash_iter (\fBhash_t\fP *hash, \fBhash_iterator\fPfunc, void *arg, \fBhash_iter_flags\fPflags)"
.PP
Iterate all hash keys and pass them to callback. \fBParameters:\fP
.RS 4
\fIhash\fP Hash to iteration 
.br
\fIfunc\fP Callback 
.br
\fIarg\fP User-defined argument for callback 
.br
\fIflags\fP Flags for iteration process 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBhash_iter_flags\fP, \fBhash_iterator\fP 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIITER_OK\fP All items iterated 
.br
\fIITER_BREAK\fP Callback returned ITER_BREAK and stopped iterations 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for frozen from the source code.
