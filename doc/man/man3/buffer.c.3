.TH "buffer.c" 3 "Tue Nov 8 2011" "Version 1.0" "frozen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
buffer.c \- 
.PP
Working with \fBbuffer_t\fP.  

.SH SYNOPSIS
.br
.PP
\fC#include <libfrozen.h>\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBMEMCMP_BUFF_SIZE\fP   1024"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBchunk_data_alloc\fP (size_t size)"
.br
.ti -1c
.RI "void * \fBchunk_bare_alloc\fP (void *ptr, size_t size)"
.br
.ti -1c
.RI "size_t \fBchunk_get_size\fP (void *chunk)"
.br
.ti -1c
.RI "void * \fBchunk_get_ptr\fP (void *chunk)"
.br
.ti -1c
.RI "void * \fBchunk_next\fP (void *chunk)"
.br
.ti -1c
.RI "void \fBchunk_free\fP (void *chunk)"
.br
.ti -1c
.RI "void \fBbuffer_init\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIInitialize buffer. \fP"
.ti -1c
.RI "\fBbuffer_t\fP * \fBbuffer_alloc\fP (void)"
.br
.RI "\fIAllocate new buffer. \fP"
.ti -1c
.RI "void \fBbuffer_io_init\fP (\fBbuffer_t\fP *buffer, void *context, func_buffer read, func_buffer write, int cached)"
.br
.RI "\fIAssociate buffer with read and write functions. \fP"
.ti -1c
.RI "\fBbuffer_t\fP * \fBbuffer_io_alloc\fP (void *context, func_buffer read, func_buffer write, int cached)"
.br
.RI "\fIAssociate buffer with read and write functions. \fP"
.ti -1c
.RI "void \fBbuffer_init_from_bare\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.RI "\fIAssociate raw memory with buffer. \fP"
.ti -1c
.RI "\fBbuffer_t\fP * \fBbuffer_alloc_from_bare\fP (void *ptr, size_t size)"
.br
.RI "\fIAllocate new buffer associated with raw memory. \fP"
.ti -1c
.RI "void \fBbuffer_init_from_copy\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.RI "\fICopy raw memory to new buffer. \fP"
.ti -1c
.RI "\fBbuffer_t\fP * \fBbuffer_alloc_from_copy\fP (void *ptr, size_t size)"
.br
.RI "\fICopy raw memory to allocated buffer. \fP"
.ti -1c
.RI "void \fBbuffer_destroy\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIDestroy buffer. \fP"
.ti -1c
.RI "void \fBbuffer_free\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIFree allocated buffer. \fP"
.ti -1c
.RI "void * \fBbuffer_defragment\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIDefragment buffer to one chunk and return pointer to this chunk. \fP"
.ti -1c
.RI "void \fBbuffer_cleanup\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIEmpty buffer. \fP"
.ti -1c
.RI "size_t \fBbuffer_get_size\fP (\fBbuffer_t\fP *buffer)"
.br
.RI "\fIGet buffer length. \fP"
.ti -1c
.RI "void * \fBbuffer_add_head_chunk\fP (\fBbuffer_t\fP *buffer, size_t size)"
.br
.ti -1c
.RI "void * \fBbuffer_add_tail_chunk\fP (\fBbuffer_t\fP *buffer, size_t size)"
.br
.ti -1c
.RI "void \fBbuffer_add_head_raw\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.ti -1c
.RI "void \fBbuffer_add_tail_raw\fP (\fBbuffer_t\fP *buffer, void *ptr, size_t size)"
.br
.ti -1c
.RI "ssize_t \fBbuffer_write\fP (\fBbuffer_t\fP *buffer, off_t write_offset, void *buf, size_t buf_size)"
.br
.RI "\fIWrite to buffer. \fP"
.ti -1c
.RI "ssize_t \fBbuffer_read\fP (\fBbuffer_t\fP *buffer, off_t read_offset, void *buf, size_t buf_size)"
.br
.RI "\fIRead from buffer. \fP"
.ti -1c
.RI "int \fBbuffer_seek\fP (\fBbuffer_t\fP *buffer, off_t b_offset, void **p_chunk, void **p_ptr, size_t *p_rest_size)"
.br
.RI "\fISeek chunk in buffer. \fP"
.ti -1c
.RI "ssize_t \fBbuffer_memcmp\fP (\fBbuffer_t\fP *buffer1, off_t buffer1_off, \fBbuffer_t\fP *buffer2, off_t buffer2_off, size_t size)"
.br
.RI "\fICompare two buffers. \fP"
.ti -1c
.RI "ssize_t \fBbuffer_memcpy\fP (\fBbuffer_t\fP *buffer1, off_t buffer1_off, \fBbuffer_t\fP *buffer2, off_t buffer2_off, size_t size)"
.br
.RI "\fICopy from one buffer to another. \fP"
.ti -1c
.RI "ssize_t \fBbuffer_strcmp\fP (\fBbuffer_t\fP *buffer1, \fBbuffer_t\fP *buffer_2)"
.br
.ti -1c
.RI "size_t \fBbuffer_strlen\fP (\fBbuffer_t\fP *buffer)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Working with \fBbuffer_t\fP. 


.SH "Function Documentation"
.PP 
.SS "\fBbuffer_t\fP* buffer_alloc (void)"
.PP
Allocate new buffer. \fBReturns:\fP
.RS 4
\fBbuffer_t\fP * or NULL 
.RE
.PP

.SS "\fBbuffer_t\fP* buffer_alloc_from_bare (void *ptr, size_tsize)"
.PP
Allocate new buffer associated with raw memory. \fBParameters:\fP
.RS 4
\fIptr\fP Pointer to raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "\fBbuffer_t\fP* buffer_alloc_from_copy (void *ptr, size_tsize)"
.PP
Copy raw memory to allocated buffer. \fBParameters:\fP
.RS 4
\fIptr\fP Raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "void buffer_cleanup (\fBbuffer_t\fP *buffer)"
.PP
Empty buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to empty 
.RE
.PP

.SS "void* buffer_defragment (\fBbuffer_t\fP *buffer)"
.PP
Defragment buffer to one chunk and return pointer to this chunk. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to defragment 
.RE
.PP
\fBReturns:\fP
.RS 4
ptr to defragmented memory 
.PP
NULL if buffer was empty 
.RE
.PP

.SS "void buffer_destroy (\fBbuffer_t\fP *buffer)"
.PP
Destroy buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to destroy 
.RE
.PP

.SS "void buffer_free (\fBbuffer_t\fP *buffer)"
.PP
Free allocated buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to free 
.RE
.PP

.SS "size_t buffer_get_size (\fBbuffer_t\fP *buffer)\fC [inline]\fP"
.PP
Get buffer length. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer 
.RE
.PP

.SS "void buffer_init (\fBbuffer_t\fP *buffer)"
.PP
Initialize buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place for buffer 
.RE
.PP

.SS "void buffer_init_from_bare (\fBbuffer_t\fP *buffer, void *ptr, size_tsize)"
.PP
Associate raw memory with buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place to write buffer structure 
.br
\fIptr\fP Pointer to raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "void buffer_init_from_copy (\fBbuffer_t\fP *buffer, void *ptr, size_tsize)"
.PP
Copy raw memory to new buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place to write buffer structure 
.br
\fIptr\fP Raw memory 
.br
\fIsize\fP Length of memory 
.RE
.PP

.SS "\fBbuffer_t\fP* buffer_io_alloc (void *context, func_bufferread, func_bufferwrite, intcached)"
.PP
Associate buffer with read and write functions. \fBParameters:\fP
.RS 4
\fIcontext\fP IO context for functions 
.br
\fIread\fP IO read function 
.br
\fIwrite\fP IO write function 
.br
\fIcached\fP Cache returned io buffers 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBbuffer_t\fP * 
.PP
NULL 
.RE
.PP

.SS "void buffer_io_init (\fBbuffer_t\fP *buffer, void *context, func_bufferread, func_bufferwrite, intcached)"
.PP
Associate buffer with read and write functions. \fBParameters:\fP
.RS 4
\fIbuffer\fP Place to write buffer structure 
.br
\fIcontext\fP IO context for functions 
.br
\fIread\fP IO read function 
.br
\fIwrite\fP IO write function 
.br
\fIcached\fP Cache returned io buffers 
.RE
.PP

.SS "ssize_t buffer_memcmp (\fBbuffer_t\fP *buffer1, off_tbuffer1_off, \fBbuffer_t\fP *buffer2, off_tbuffer2_off, size_tsize)"
.PP
Compare two buffers. \fBParameters:\fP
.RS 4
\fIbuffer1\fP First buffer 
.br
\fIbuffer1_off\fP First buffer offset 
.br
\fIbuffer2\fP Second buffer 
.br
\fIbuffer2_off\fP Second buffer offset 
.br
\fIsize\fP Size to compare 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if buffers equal 
.PP
1 or -1 if buffers differs 
.RE
.PP

.SS "ssize_t buffer_memcpy (\fBbuffer_t\fP *buffer1, off_tbuffer1_off, \fBbuffer_t\fP *buffer2, off_tbuffer2_off, size_tsize)"
.PP
Copy from one buffer to another. \fBParameters:\fP
.RS 4
\fIbuffer1\fP First buffer 
.br
\fIbuffer1_off\fP First buffer offset 
.br
\fIbuffer2\fP Second buffer 
.br
\fIbuffer2_off\fP Second buffer offset 
.br
\fIsize\fP Size to copy 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.PP
-EINVAL on error 
.RE
.PP

.SS "ssize_t buffer_read (\fBbuffer_t\fP *buffer, off_tread_offset, void *buf, size_tbuf_size)"
.PP
Read from buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer 
.br
\fIread_offset\fP Offset to start writing 
.br
\fIbuf\fP Read to ptr 
.br
\fIbuf_size\fP Read length 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bytes read 
.PP
IO function error 
.PP
-1 
.RE
.PP

.SS "int buffer_seek (\fBbuffer_t\fP *buffer, off_tb_offset, void **p_chunk, void **p_ptr, size_t *p_rest_size)"
.PP
Seek chunk in buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer to seek 
.br
\fIb_offset\fP Offset 
.br
\fIp_chunk\fP Found chunk pointer 
.br
\fIp_ptr\fP Memory ptr 
.br
\fIp_rest_size\fP Memory size 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.PP
-EINVAL on error 
.RE
.PP

.SS "ssize_t buffer_write (\fBbuffer_t\fP *buffer, off_twrite_offset, void *buf, size_tbuf_size)"
.PP
Write to buffer. \fBParameters:\fP
.RS 4
\fIbuffer\fP Buffer 
.br
\fIwrite_offset\fP Offset to start writing 
.br
\fIbuf\fP Ptr to memory 
.br
\fIbuf_size\fP Write length 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bytes written 
.PP
IO function error 
.PP
-1 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for frozen from the source code.
